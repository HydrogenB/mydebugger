"use strict";exports.id=530,exports.ids=[530],exports.modules={3530:(e,r,t)=>{function a(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);r&&(a=a.filter(function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable})),t.push.apply(t,a)}return t}function i(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?a(Object(t),!0).forEach(function(r){var a,i;a=r,i=t[r],(a=function(e){var r=function(e,r){if("object"!=typeof e||null===e)return e;var t=e[Symbol.toPrimitive];if(void 0!==t){var a=t.call(e,r||"default");if("object"!=typeof a)return a;throw TypeError("@@toPrimitive must return a primitive value.")}return("string"===r?String:Number)(e)}(e,"string");return"symbol"==typeof r?r:String(r)}(a))in e?Object.defineProperty(e,a,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[a]=i}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach(function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))})}return e}t.r(r),t.d(r,{analyze:()=>E,analyzeToken:()=>g,base64UrlDecode:()=>o,base64UrlEncode:()=>n,bench:()=>v,benchmarkAlgorithm:()=>k,decode:()=>A,decodeSafely:()=>c,generateKeyPair:()=>S,sign:()=>b,signToken:()=>f,verify:()=>w,verifyToken:()=>m});let n=e=>btoa(e).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,""),o=e=>{switch((e=e.replace(/-/g,"+").replace(/_/g,"/")).length%4){case 0:break;case 2:e+="==";break;case 3:e+="=";break;default:throw Error("Invalid base64url string")}try{return decodeURIComponent(escape(atob(e)))}catch(r){try{return atob(e)}catch(e){throw Error("Invalid base64 content")}}},s=e=>/^-----BEGIN ([A-Z\s]+)-----/.test(e)&&/-----END ([A-Z\s]+)-----$/.test(e),l=e=>{let r=e.match(/^-----BEGIN [^-]+-----\s*([A-Za-z0-9+\/=\s]+)-----END [^-]+-----$/s);if(!r||!r[1])throw Error("Invalid PEM format");return r[1].replace(/[\n\r\s]/g,"")},h=e=>{if(s(e)){let r=e.includes("PRIVATE KEY");e.includes("PUBLIC KEY");let t=e.includes("RSA"),a=e.includes("EC")||e.includes("ECDSA");return{format:r?"pkcs8":"spki",isBase64:!1,isPem:!0,keyType:t?"RSA":a?"EC":"unknown"}}return{format:"raw",isBase64:/^[A-Za-z0-9+/=]+$/.test(e.trim()),isPem:!1,keyType:e.length>100?"RSA":"HMAC"}},d=e=>{let r=[],t=e;return e!==e.trim()&&r.push("Token contains extra whitespace that was removed"),(t=t.trim()).toLowerCase().startsWith("bearer ")&&(t=t.substring(7).trim(),r.push("Bearer prefix was removed from token")),t.includes("\\n")&&(t=t.replace(/\\n/g,""),r.push("Escaped newlines were removed from token")),t.includes("\n")&&(t=t.replace(/\n/g,""),r.push("Newlines were removed from token")),{token:t,warnings:r}},c=async e=>{try{let r;let{token:t,warnings:a}=d(e);if(!(e=t))return{header:null,payload:null,signature:null,isValid:!1,raw:{header:"",payload:"",signature:""},error:"Empty token",parsingWarnings:a};let i=e.split(".");if(3!==i.length)return a.push(`Token has ${i.length} parts instead of the expected 3 parts`),{header:i.length>0?p(i[0]):null,payload:i.length>1?p(i[1]):null,signature:i.length>2?i[2]:null,isValid:!1,raw:{header:i.length>0?i[0]:"",payload:i.length>1?i[1]:"",signature:i.length>2?i[2]:""},error:"Invalid JWT format: expected 3 parts",parsingWarnings:a};let[n,s,l]=i,h=null,c=null;try{let e=o(n);(h=JSON.parse(e))&&!h.alg&&a.push('Token header is missing the "alg" field'),h&&!h.typ&&-1===a.indexOf('Token header is missing the "typ" field')&&a.push('Token header is missing the "typ" field')}catch(e){a.push("Failed to decode header as JSON"),r="Invalid JWT header: failed to parse"}try{let e=o(s);if(c=JSON.parse(e)){if(void 0!==c.exp){let e=new Date(1e3*c.exp),r=new Date;e<r&&a.push(`Token is expired (exp: ${e.toISOString()}, now: ${r.toISOString()})`)}else a.push('Token payload is missing the "exp" field');if(void 0!==c.nbf){let e=new Date(1e3*c.nbf),r=new Date;e>r&&a.push(`Token is not yet valid (nbf: ${e.toISOString()}, now: ${r.toISOString()})`)}void 0===c.iat&&a.push('Token payload is missing the "iat" field')}}catch(e){a.push("Failed to decode payload as JSON"),r=r||"Invalid JWT payload: failed to parse"}return{header:h,payload:c,signature:l,isValid:!1,raw:{header:n,payload:s,signature:l},error:r,parsingWarnings:a.length>0?a:void 0}}catch(e){return{header:null,payload:null,signature:null,isValid:!1,raw:{header:"",payload:"",signature:""},error:e instanceof Error?e.message:"Unknown error decoding token"}}};function p(e){try{let r=o(e);return JSON.parse(r)}catch(e){return null}}let u=(e,r=!1)=>{if(s(e))try{let r=l(e),t=atob(r),a=new Uint8Array(t.length);for(let e=0;e<t.length;e++)a[e]=t.charCodeAt(e);return a.buffer}catch(e){throw console.error("PEM parsing failed:",e),Error("Invalid PEM format key")}if(!r)return new TextEncoder().encode(e).buffer;try{let r=atob(e),t=new Uint8Array(r.length);for(let e=0;e<r.length;e++)t[e]=r.charCodeAt(e);return t.buffer}catch(e){throw console.error("Base64 parsing failed:",e),Error("Invalid base64 encoded key")}},y=async(e,r,t,a,i,n,o)=>{let{format:s,isBase64:l,isPem:d,keyType:c}=h(r),p=[{isBase64:l,keyFormat:s},{isBase64:!1,keyFormat:o?"raw":"spki"},{isBase64:!0,keyFormat:o?"raw":"spki"}];for(let e of(o?p.push({isBase64:!1,keyFormat:"raw"},{isBase64:!0,keyFormat:"raw"}):t.startsWith("RS")||t.startsWith("PS")?p.push({isBase64:!1,keyFormat:"spki"},{isBase64:d,keyFormat:"spki"}):t.startsWith("ES")&&p.push({isBase64:!1,keyFormat:"spki"},{isBase64:d,keyFormat:"spki"}),p))try{let t=u(r,e.isBase64),o=await window.crypto.subtle.importKey(e.keyFormat,t,a,!1,["verify"]),s=new TextEncoder().encode(i);if(await window.crypto.subtle.verify(a,o,n,s))return!0}catch(r){console.log(`Key format ${e.keyFormat} (base64: ${e.isBase64}) failed:`,r)}return!1},m=async(e,r)=>{try{let t,a;if(!e||""===e.trim())throw Error("Token is empty");let i=e.split(".");if(3!==i.length)throw Error("Invalid token format (should have 3 parts)");let[n,o,s]=i;if(!s||""===s.trim())return!1;try{t=p(n)}catch(e){throw Error("Invalid token header (not valid base64 or JSON)")}if(!t||!t.alg)throw Error("Token header missing algorithm (alg)");let l=t.alg;if("none"===l)return!1;let h=Uint8Array.from(atob(s.replace(/-/g,"+").replace(/_/g,"/")),e=>e.charCodeAt(0)),d=!1;switch(l){case"HS256":a={name:"HMAC",hash:"SHA-256"},d=!0;break;case"HS384":a={name:"HMAC",hash:"SHA-384"},d=!0;break;case"HS512":a={name:"HMAC",hash:"SHA-512"},d=!0;break;case"RS256":a={name:"RSASSA-PKCS1-v1_5",hash:"SHA-256"};break;case"RS384":a={name:"RSASSA-PKCS1-v1_5",hash:"SHA-384"};break;case"RS512":a={name:"RSASSA-PKCS1-v1_5",hash:"SHA-512"};break;case"PS256":a={name:"RSA-PSS",hash:"SHA-256"};break;case"PS384":a={name:"RSA-PSS",hash:"SHA-384"};break;case"PS512":a={name:"RSA-PSS",hash:"SHA-512"};break;case"ES256":a={name:"ECDSA",hash:"SHA-256",namedCurve:"P-256"};break;case"ES384":a={name:"ECDSA",hash:"SHA-384",namedCurve:"P-384"};break;case"ES512":a={name:"ECDSA",hash:"SHA-512",namedCurve:"P-521"};break;default:throw Error(`Unsupported algorithm: ${l}`)}return await y(e,r,l,a,`${n}.${o}`,h,d)}catch(e){throw console.error("Token verification error:",e),e}},f=async(e,r,t)=>{try{let a,o;let s=i({typ:"JWT"},e),l=s.alg;if(!l)throw Error("Algorithm is required in header");let d=n(JSON.stringify(s)),c=n(JSON.stringify(r)),p=`${d}.${c}`;if("none"===l)return`${p}.`;switch(l){case"HS256":a={name:"HMAC",hash:"SHA-256"};break;case"HS384":a={name:"HMAC",hash:"SHA-384"};break;case"HS512":a={name:"HMAC",hash:"SHA-512"};break;case"RS256":a={name:"RSASSA-PKCS1-v1_5",hash:"SHA-256"};break;case"RS384":a={name:"RSASSA-PKCS1-v1_5",hash:"SHA-384"};break;case"RS512":a={name:"RSASSA-PKCS1-v1_5",hash:"SHA-512"};break;case"PS256":a={name:"RSA-PSS",hash:"SHA-256"};break;case"PS384":a={name:"RSA-PSS",hash:"SHA-384"};break;case"PS512":a={name:"RSA-PSS",hash:"SHA-512"};break;case"ES256":a={name:"ECDSA",hash:"SHA-256",namedCurve:"P-256"};break;case"ES384":a={name:"ECDSA",hash:"SHA-384",namedCurve:"P-384"};break;case"ES512":a={name:"ECDSA",hash:"SHA-512",namedCurve:"P-521"};break;default:throw Error(`Unsupported algorithm: ${l}`)}let{format:y,isBase64:m,isPem:f}=h(t);o=f?u(t,!1):u(t,m);let S=await window.crypto.subtle.importKey(y,o,a,!1,["sign"]),g=new TextEncoder().encode(p),k=await window.crypto.subtle.sign(a,S,g),b=new Uint8Array(k),w="";for(let e=0;e<b.length;e++)w+=String.fromCharCode(b[e]);return w=n(w),`${p}.${w}`}catch(e){throw console.error("JWT signing error:",e),e}},S=async(e,r=2048)=>{let t;if(e.startsWith("RS"))t={name:"RSASSA-PKCS1-v1_5",modulusLength:r,publicExponent:new Uint8Array([1,0,1]),hash:{name:e.replace("RS","SHA-")}};else if(e.startsWith("ES")){let r="P-256";"ES384"===e&&(r="P-384"),"ES512"===e&&(r="P-521"),t={name:"ECDSA",namedCurve:r}}else throw Error(`Unsupported algorithm for key generation: ${e}`);let{publicKey:a,privateKey:i}=await window.crypto.subtle.generateKey(t,!0,["sign","verify"]),n=await window.crypto.subtle.exportKey("spki",a),o=await window.crypto.subtle.exportKey("pkcs8",i),s=btoa(String.fromCharCode(...new Uint8Array(n))),l=btoa(String.fromCharCode(...new Uint8Array(o)));return{publicKey:`-----BEGIN PUBLIC KEY-----
${s}
-----END PUBLIC KEY-----`,privateKey:`-----BEGIN PRIVATE KEY-----
${l}
-----END PRIVATE KEY-----`}},g=async e=>{let r=[];try{let t=await c(e);if(!t.header)return r.push({id:"malformed-token",title:"Malformed Token",description:"The token could not be parsed correctly.",severity:"high"}),r;let a=t.header.alg;if(a?("none"===a&&r.push({id:"alg-none",title:'Insecure "none" Algorithm',description:'The token uses the "none" algorithm which is insecure and vulnerable to signature bypass attacks.',severity:"high"}),"HS256"===a&&r.push({id:"weak-hs256",title:"Consider Stronger Algorithm",description:"While acceptable, HS256 offers lower security than HS384 or HS512. Consider using a stronger algorithm for sensitive applications.",severity:"info"})):r.push({id:"missing-alg",title:"Missing Algorithm",description:'The token header is missing the required "alg" field.',severity:"high"}),t.signature&&0!==t.signature.length||r.push({id:"missing-signature",title:"Missing Signature",description:"The token has no signature, making it unverifiable and insecure.",severity:"high"}),t.payload){if(t.payload.exp){let e=Math.floor(Date.now()/1e3);t.payload.exp<e&&r.push({id:"token-expired",title:"Token Expired",description:`The token expired on ${new Date(1e3*t.payload.exp).toLocaleString()}.`,severity:"medium"})}else r.push({id:"no-exp",title:"No Expiration",description:"The token does not have an expiration time (exp claim) which is a security risk.",severity:"medium"});if(t.payload.iat||r.push({id:"no-iat",title:"No Issuance Time",description:"The token does not have an issuance time (iat claim). This makes token revocation more difficult.",severity:"low"}),t.payload.aud||r.push({id:"no-aud",title:"No Audience",description:"The token does not specify an audience (aud claim). This could lead to token misuse across different services.",severity:"low"}),t.payload.iss||r.push({id:"no-iss",title:"No Issuer",description:"The token does not specify an issuer (iss claim). This could lead to confusion about token origin.",severity:"low"}),t.payload.nbf){let e=Math.floor(Date.now()/1e3);t.payload.nbf>e&&r.push({id:"not-valid-yet",title:"Token Not Valid Yet",description:`The token becomes valid on ${new Date(1e3*t.payload.nbf).toLocaleString()}.`,severity:"medium"})}else r.push({id:"no-nbf",title:'No "Not Before" Time',description:'The token does not specify a "not before" time (nbf claim). While not critical, this helps prevent token use before intended.',severity:"info"});t.payload.jti||r.push({id:"no-jti",title:"No JWT ID",description:"The token does not have a JWT ID (jti claim). This makes token revocation and tracking more difficult.",severity:"info"})}t.header.typ?"JWT"!==t.header.typ&&r.push({id:"unusual-typ",title:"Unusual Token Type",description:`The token specifies an unusual type: "${t.header.typ}" instead of the standard "JWT".`,severity:"info"}):r.push({id:"no-typ",title:"No Token Type",description:"The token does not specify a type (typ claim) in the header. This is recommended for interoperability.",severity:"info"}),t.header.kid||r.push({id:"no-kid",title:"No Key ID",description:"The token does not specify a key ID (kid header). This is recommended when multiple keys are used.",severity:"info"})}catch(e){r.push({id:"parse-error",title:"Token Parse Error",description:e instanceof Error?e.message:"Unknown error parsing token",severity:"high"})}return r},k=async e=>{let r={sub:"1234567890",name:"John Doe",iat:Math.floor(Date.now()/1e3),exp:Math.floor(Date.now()/1e3)+3600,data:Array(1024).fill("a").join("")},t={alg:e,typ:"JWT"},a=Array(32).fill(0).map(()=>Math.floor(256*Math.random()).toString(16).padStart(2,"0")).join(""),n=performance.now();for(let n=0;n<100;n++)try{await f(t,i(i({},r),{},{nonce:n}),a)}catch(r){return console.error(`Error benchmarking algorithm ${e}:`,r),0}return Math.floor(100/((performance.now()-n)/1e3))},b=f,w=m,A=c,v=k,E=g}};