/**
 * © 2025 MyDebugger Contributors – MIT License
 */
import { useEffect, useState, useCallback } from 'react';
import {
  ValidationStatus,
  TestResult,
  normalizeUrl,
  buildRedirectTestUrl,
  buildXssTestUrl,
  checkHttpsRedirect,
  checkCors,
  checkOpenRedirect,
  checkXssReflection,
} from '../lib/pentest';
import { testFunctionWithEdgeCases } from '../../../shared/utils/edgeCaseTestHelpers';

interface Results {
  https?: TestResult;
  cors?: TestResult;
  openRedirect?: TestResult;
  xss?: TestResult;
  clickjacking?: ValidationStatus;
}

interface WindowState {
  id: string;
  title: string;
  url: string;
  status: 'loading' | 'loaded' | 'error' | 'blocked';
  dimensions: { width: number; height: number };
  isResizable: boolean;
  isMinimized: boolean;
  lastActivity: number;
  errorDetails?: string;
}

interface PayloadTest {
  name: string;
  payload: string;
  category: 'xss' | 'sqli' | 'command' | 'path' | 'header';
  riskLevel: 'low' | 'medium' | 'high';
  description: string;
}

export const usePentestSuite = () => {
  const [url, setUrl] = useState('');
  const [results, setResults] = useState<Results>({});
  const [redirectUrl, setRedirectUrl] = useState('');
  const [xssUrl, setXssUrl] = useState('');
  const [httpUrl, setHttpUrl] = useState('');
  const [redirectParam, setRedirectParam] = useState('redirect');
  const [xssPayload, setXssPayload] = useState('<img src=x onerror=alert(1)>');
  const [history, setHistory] = useState<string[]>([]);
  const [runId, setRunId] = useState(0);
  const [loading, setLoading] = useState(false);
  
  // Enhanced interactive features
  const [windows, setWindows] = useState<WindowState[]>([]);
  const [payloadTests, setPayloadTests] = useState<PayloadTest[]>([]);
  const [isAdvancedMode, setIsAdvancedMode] = useState(false);
  const [autoResize, setAutoResize] = useState(true);
  const [realPayloadMode, setRealPayloadMode] = useState(false);
  const [edgeCaseResults, setEdgeCaseResults] = useState<Record<string, unknown>>({});
  const [activeWindow, setActiveWindow] = useState<string | null>(null);

  useEffect(() => {
    const saved = localStorage.getItem('MyDebugger:pentest-history');
    if (saved) setHistory(JSON.parse(saved));
    
    // Initialize default payloads for real payload testing
    const defaultPayloads: PayloadTest[] = [
      {
        name: 'Basic XSS',
        payload: '<script>alert("XSS")</script>',
        category: 'xss',
        riskLevel: 'high',
        description: 'Basic script injection test'
      },
      {
        name: 'Event Handler XSS',
        payload: '<img src=x onerror=alert("XSS")>',
        category: 'xss',
        riskLevel: 'high',
        description: 'XSS via error event handler'
      },
      {
        name: 'SVG XSS',
        payload: '<svg onload=alert("XSS")>',
        category: 'xss',
        riskLevel: 'medium',
        description: 'XSS via SVG element'
      },
      {
        name: 'SQL Injection',
        payload: "' OR 1=1--",
        category: 'sqli',
        riskLevel: 'high',
        description: 'Basic SQL injection test'
      },
      {
        name: 'Path Traversal',
        payload: '../../../etc/passwd',
        category: 'path',
        riskLevel: 'high',
        description: 'Directory traversal test'
      },
      {
        name: 'Command Injection',
        payload: '; cat /etc/passwd #',
        category: 'command',
        riskLevel: 'high',
        description: 'Command injection test'
      }
    ];
    setPayloadTests(defaultPayloads);
  }, [setPayloadTests]);

  const saveHistory = useCallback((u: string) => {
    setHistory((prev) => {
      const updated = [u, ...prev.filter((v) => v !== u)].slice(0, 5);
      localStorage.setItem('MyDebugger:pentest-history', JSON.stringify(updated));
      return updated;
    });
  }, []);

  // Window management functions
  const createWindow = useCallback((id: string, title: string, testUrl: string) => {
    const newWindow: WindowState = {
      id,
      title,
      url: testUrl,
      status: 'loading',
      dimensions: autoResize ? { width: 800, height: 600 } : { width: 400, height: 300 },
      isResizable: true,
      isMinimized: false,
      lastActivity: Date.now()
    };
    
    setWindows(prev => [...prev.filter(w => w.id !== id), newWindow]);
    setActiveWindow(id);
  }, [autoResize, setWindows, setActiveWindow]);

  const updateWindowStatus = useCallback((id: string, status: WindowState['status'], errorDetails?: string) => {
    setWindows(prev => prev.map(w => 
      w.id === id 
        ? { ...w, status, errorDetails, lastActivity: Date.now() }
        : w
    ));
  }, [setWindows]);

  const resizeWindow = useCallback((id: string, dimensions: { width: number; height: number }) => {
    setWindows(prev => prev.map(w => 
      w.id === id 
        ? { ...w, dimensions, lastActivity: Date.now() }
        : w
    ));
  }, [setWindows]);

  const minimizeWindow = useCallback((id: string) => {
    setWindows(prev => prev.map(w => 
      w.id === id 
        ? { ...w, isMinimized: !w.isMinimized, lastActivity: Date.now() }
        : w
    ));
  }, [setWindows]);

  const closeWindow = useCallback((id: string) => {
    setWindows(prev => prev.filter(w => w.id !== id));
    setActiveWindow(prev => prev === id ? null : prev);
  }, [setWindows, setActiveWindow]);

  // Edge case testing
  const runEdgeCaseTests = useCallback(async (targetUrl: string) => {
    const testResultsMap: Record<string, unknown> = {};
    
    // Test with various edge case URLs
    const urlEdgeCases = [
      '',
      // Potentially dangerous URL schemes (for testing purposes)
      'data:text/html,<script>alert(1)</script>',
      'file:///etc/passwd',
      'ftp://example.com',
      'https://localhost:9999/nonexistent',
      `${targetUrl}/${'A'.repeat(10000)}`, // Very long path
      `${targetUrl}?param=${'B'.repeat(5000)}`, // Very long query
    ];

    // Test each URL case sequentially to avoid overwhelming the system
    const testPromises = urlEdgeCases.map(async (testUrl) => {
      try {
        const result = await testFunctionWithEdgeCases(
          (inputUrl: string) => checkHttpsRedirect(inputUrl),
          [{ name: 'Edge case URL', input: testUrl }]
        );
        return { url: testUrl, result };
      } catch (error) {
        return { 
          url: testUrl, 
          result: { error: error instanceof Error ? error.message : 'Unknown error' }
        };
      }
    });

    const promiseResults = await Promise.allSettled(testPromises);
    promiseResults.forEach((promiseResult, index) => {
      if (promiseResult.status === 'fulfilled') {
        testResultsMap[urlEdgeCases[index]] = promiseResult.value.result;
      } else {
        testResultsMap[urlEdgeCases[index]] = { error: promiseResult.reason };
      }
    });

    setEdgeCaseResults(testResultsMap);
    return testResultsMap;
  }, [setEdgeCaseResults]);

  // Advanced payload testing
  const runPayloadTest = useCallback(async (payload: PayloadTest, targetUrl: string) => {
    const testUrl = buildXssTestUrl(targetUrl, payload.payload);
    createWindow(`payload-${payload.name}`, `${payload.name} Test`, testUrl);
    
    try {
      let result;
      switch (payload.category) {
        case 'xss':
          result = await checkXssReflection(targetUrl, payload.payload);
          break;
        case 'sqli':
          // For SQL injection, we just test if the payload is reflected
          result = await checkXssReflection(targetUrl, payload.payload, 'q');
          break;
        default:
          result = await checkXssReflection(targetUrl, payload.payload);
      }
      
      updateWindowStatus(`payload-${payload.name}`, 
        result.status === 'failed' ? 'error' : 'loaded', 
        result.details
      );
      
      return result;
    } catch (error) {
      updateWindowStatus(`payload-${payload.name}`, 'error', 
        error instanceof Error ? error.message : 'Unknown error'
      );
      throw error;
    }
  }, [createWindow, updateWindowStatus]);

  const runTests = async () => {
    if (!url) return;
    setLoading(true);
    
    try {
      const target = normalizeUrl(url.trim());
      saveHistory(target);
      setRunId((id) => id + 1);
      setRedirectUrl(buildRedirectTestUrl(target, redirectParam));
      setXssUrl(buildXssTestUrl(target, xssPayload));
      setHttpUrl(target.replace(/^https:/, 'http:'));
      
      // Create windows for real-time testing when in advanced mode
      if (isAdvancedMode) {
        createWindow('https-test', 'HTTPS Redirect Test', target.replace(/^https:/, 'http:'));
        createWindow('cors-test', 'CORS Test', target);
        createWindow('redirect-test', 'Open Redirect Test', buildRedirectTestUrl(target, redirectParam));
        createWindow('xss-test', 'XSS Test', buildXssTestUrl(target, xssPayload));
      }
      
      // Run basic tests
      const https = await checkHttpsRedirect(target);
      const cors = await checkCors(target);
      const openRedirect = await checkOpenRedirect(target, redirectParam);
      const xss = await checkXssReflection(target, xssPayload);
      
      // Update window statuses if in advanced mode
      if (isAdvancedMode) {
        updateWindowStatus('https-test', https.status === 'passed' ? 'loaded' : 'error', https.details);
        updateWindowStatus('cors-test', cors.status === 'passed' ? 'loaded' : 'error', cors.details);
        updateWindowStatus('redirect-test', openRedirect.status === 'passed' ? 'loaded' : 'error', openRedirect.details);
        updateWindowStatus('xss-test', xss.status === 'passed' ? 'loaded' : 'error', xss.details);
      }
      
      // Run real payload tests if enabled
      if (realPayloadMode && payloadTests.length > 0) {
        await Promise.allSettled(
          payloadTests.map(payload => runPayloadTest(payload, target))
        );
        // Real payload results are handled individually in runPayloadTest
      }
      
      // Run edge case tests if in advanced mode
      if (isAdvancedMode) {
        await runEdgeCaseTests(target);
      }
      
      setResults({ https, cors, openRedirect, xss, clickjacking: 'inconclusive' });
    } finally {
      setLoading(false);
    }
  };

  const setClickjacking = (status: ValidationStatus) => {
    setResults((prev) => ({ ...prev, clickjacking: status }));
  };

  return {
    url,
    setUrl,
    results,
    redirectUrl,
    xssUrl,
    httpUrl,
    redirectParam,
    setRedirectParam,
    xssPayload,
    setXssPayload,
    runTests,
    history,
    runId,
    setClickjacking,
    loading,
    // Enhanced interactive features
    windows,
    payloadTests,
    isAdvancedMode,
    setIsAdvancedMode,
    autoResize,
    setAutoResize,
    realPayloadMode,
    setRealPayloadMode,
    edgeCaseResults,
    activeWindow,
    setActiveWindow,
    createWindow,
    updateWindowStatus,
    resizeWindow,
    minimizeWindow,
    closeWindow,
    runEdgeCaseTests,
    runPayloadTest,
  };
};

export default usePentestSuite;
