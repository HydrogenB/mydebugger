/**
 * © 2025 MyDebugger Contributors – MIT License
 */

export type ValidationStatus = 'passed' | 'failed' | 'inconclusive';

export interface TestResult {
  status: ValidationStatus;
  details?: string;
}

export const normalizeUrl = (input: string): string => {
  try {
    const url = new URL(input.startsWith('http') ? input : `http://${input}`);
    return url.href;
  } catch {
    return input;
  }
};

export const buildRedirectTestUrl = (
  url: string,
  param: string = 'redirect'
): string => {
  const u = new URL(url);
  if (!u.searchParams.has(param)) {
    u.searchParams.set(param, 'https://example.com');
  }
  return u.toString();
};

export const buildXssTestUrl = (
  url: string,
  payload: string = '<img src=x onerror=alert(1)>',
  param: string = 'q'
): string => {
  const u = new URL(url);
  u.searchParams.set(param, payload);
  return u.toString();
};

export const checkHttpsRedirect = async (url: string): Promise<TestResult> => {
  const normalized = normalizeUrl(url);
  if (normalized.startsWith('https://')) {
    return { status: 'passed', details: 'Already HTTPS' };
  }
  try {
    const res = await fetch(normalized, { redirect: 'follow' });
    if (res.redirected && res.url.startsWith('https://')) {
      return { status: 'passed', details: 'Redirects to HTTPS' };
    }
    if (res.type === 'opaque') {
      return { status: 'inconclusive', details: 'CORS prevents inspection' };
    }
    return { status: 'failed', details: 'No HTTPS redirect' };
  } catch {
    return { status: 'inconclusive', details: 'Fetch error' };
  }
};

export const checkCors = async (url: string): Promise<TestResult> => {
  try {
    const res = await fetch(url, { method: 'GET' });
    if (res.type === 'opaque') {
      return { status: 'passed', details: 'Browser blocked access' };
    }
    return { status: 'failed', details: 'CORS headers allow access' };
  } catch {
    return { status: 'inconclusive', details: 'Network error' };
  }
};

export const checkXssReflection = async (
  url: string,
  payload: string = '<script>1</script>',
  param: string = 'q'
): Promise<TestResult> => {
  try {
    const u = new URL(url);
    u.searchParams.set(param, payload);
    const res = await fetch(u.toString());
    if (res.type === 'opaque') {
      return { status: 'inconclusive', details: 'CORS prevents inspection' };
    }
    const text = await res.text();
    return text.includes(payload)
      ? { status: 'failed', details: 'Payload reflected in response' }
      : { status: 'passed' };
  } catch {
    return { status: 'inconclusive', details: 'Network error' };
  }
};

export const checkOpenRedirect = async (
  url: string,
  param: string = 'redirect'
): Promise<TestResult> => {
  try {
    const testUrl = buildRedirectTestUrl(url, param);
    const res = await fetch(testUrl, { redirect: 'manual' });
    if (res.type === 'opaque') {
      return { status: 'inconclusive', details: 'CORS prevents inspection' };
    }
    if (res.status >= 300 && res.status < 400) {
      const loc = res.headers.get('location') || '';
      if (loc.startsWith('https://example.com')) {
        return { status: 'failed', details: 'Unvalidated redirect' };
      }
    }
    return { status: 'passed' };
  } catch {
    return { status: 'inconclusive', details: 'Network error' };
  }
};
